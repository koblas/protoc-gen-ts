import * as fs from "fs";
import * as path from "path";
import ts from "typescript";

import * as types from "./types";
import * as rpc from "./rpc";
import * as descriptor from "./descriptor";
import { google_protobuf_compiler as plugin } from "./compiler/plugin";
import { parseParameters } from "./config";

function createImport(
  identifier: ts.Identifier,
  moduleSpecifier: string,
): ts.ImportDeclaration {
  return ts.factory.createImportDeclaration(
    undefined,
    undefined,
    ts.factory.createImportClause(
      false,
      // ts.factory.createNamespaceImport(identifier),
      identifier,
      undefined,
    ),
    ts.factory.createStringLiteral(moduleSpecifier),
  );
}

function replaceExtension(filename: string, extension = ".ts") {
  return filename.replace(/\.[^/.]+$/, extension);
}

function main() {
  const request = plugin.CodeGeneratorRequest.deserialize(
    new Uint8Array(fs.readFileSync(0)),
  );
  const configParams = parseParameters(request.parameter);

  request.proto_file.forEach((desc) => {
    types.preprocess(desc, desc.name, `.${desc.package || ""}`);
  });

  const files = request.proto_file.map((fileDescriptor) => {
    // after each iteration we need to clear the dependency map to prevent accidental
    // misuse of identifiers
    types.resetDependencyMap();

    const name = replaceExtension(fileDescriptor.name);
    const pbIdentifier = ts.factory.createUniqueName("pb");
    const grpcIdentifier = ts.factory.createUniqueName("grpc");

    // Will keep track of import statements
    const importStatements = [];

    // Create all named imports from dependencies
    fileDescriptor.dependency.forEach((dependency) => {
      const identifier = ts.factory.createUniqueName("dependency");
      const moduleSpecifier = replaceExtension(dependency, "");
      types.setIdentifierForDependency(dependency, identifier);
      const importedFrom = `./${path.relative(
        path.dirname(fileDescriptor.name),
        moduleSpecifier,
      )}`;
      importStatements.push(createImport(identifier, importedFrom));
    });

    // Create all messages recursively
    let statements: ts.Statement[] = [];

    // Process enums
    fileDescriptor.enum_type.forEach((enumDescriptor) => {
      statements.push(descriptor.createEnum(enumDescriptor));
    });

    // Process root messages
    fileDescriptor.message_type.forEach((messageDescriptor) => {
      statements.push(
        ...descriptor.processDescriptorRecursively(
          fileDescriptor,
          messageDescriptor,
          pbIdentifier,
        ),
      );
    });

    if (statements.length) {
      importStatements.push(createImport(pbIdentifier, "google-protobuf"));
    }

    if (fileDescriptor.service.length) {
      // Import grpc only if there is service statements
      importStatements.push(
        createImport(grpcIdentifier, configParams.grpc_package),
      );
      statements.push(
        ...rpc.createGrpcInterfaceType(
          fileDescriptor,
          grpcIdentifier,
          configParams,
        ),
      );
      // Create all services and clients
      fileDescriptor.service.forEach((serviceDescriptor) => {
        statements.push(
          rpc.createUnimplementedService(
            fileDescriptor,
            serviceDescriptor,
            grpcIdentifier,
          ),
        );
        statements.push(
          rpc.createServiceClient(
            fileDescriptor,
            serviceDescriptor,
            grpcIdentifier,
            configParams,
          ),
        );
      });
    }

    // Wrap statements within the namespace
    if (fileDescriptor.package) {
      statements = [
        ...importStatements,
        descriptor.createNamespace(fileDescriptor.package, statements),
      ];
    } else {
      statements = [...importStatements, ...statements];
    }

    const sourcefile = ts.factory.createSourceFile(
      statements,
      ts.factory.createToken(ts.SyntaxKind.EndOfFileToken),
      ts.NodeFlags.None,
    );

    const { major, minor, patch } = request.compiler_version || {
      major: 0,
      minor: 0,
      patch: 0,
    };

    ts.addSyntheticLeadingComment(
      statements[0],
      ts.SyntaxKind.MultiLineCommentTrivia,
      " eslint-disable ",
      true,
    );
    ts.addSyntheticLeadingComment(
      statements[0],
      ts.SyntaxKind.MultiLineCommentTrivia,
      `
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: ${major}.${minor}.${patch}
 * source: ${fileDescriptor.name}
 * git: https://github.com/thesayyn/protoc-gen-ts
 * buymeacoffee: https://www.buymeacoffee.com/thesayyn
`,
      true,
    );

    (sourcefile as any).identifiers = new Set();

    const content = ts
      .createPrinter({
        newLine: ts.NewLineKind.LineFeed,
        omitTrailingSemicolon: true,
      })
      .printFile(sourcefile);

    return new plugin.CodeGeneratorResponse.File({
      name,
      content,
    });
  });

  const response = new plugin.CodeGeneratorResponse({
    supported_features:
      plugin.CodeGeneratorResponse.Feature.FEATURE_PROTO3_OPTIONAL,
    file: files,
  });

  process.stdout.write(response.serialize());
}

main();
